/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package sandbox.explorer

import arrow.core.Either
import arrow.fx.ForIO
import arrow.fx.IO
import arrow.fx.extensions.fx
import arrow.fx.extensions.io.monad.monad
import arrow.fx.fix
import arrow.fx.handleError
import arrow.mtl.EitherT
import arrow.mtl.extensions.eithert.monad.monad
import arrow.mtl.value
import java.io.File
import java.sql.Connection
import org.jetbrains.exposed.sql.Database
import org.jetbrains.exposed.sql.transactions.TransactionManager
import sandbox.explorer.logic.CsvUserImporter
import sandbox.explorer.logic.PeopleProcessor

enum class RunMode {
    NORMAL, PARALLEL
}

suspend fun main(args: Array<String>) =
    IO.fx {
        val runMode: RunMode = if (args.any() && args.first() == "parallel") {
            RunMode.PARALLEL
        } else {
            RunMode.NORMAL
        }

        // val result = ! App.run(runMode).value().fix()
        val result = ! App.run(runMode)

        when (result) {
            is Either.Left -> println("Error occurred - ${result.a}")
            is Either.Right -> println("Success!! - ${result.b}")
        }
    }
    .handleError { err -> println("::: Fatal error occurred: ${err.message} ") }
    .suspended()

object App {
    fun connectToDatabase(): Database {
        val filePath = File("db/explorer-db.sqlt").getAbsolutePath()
        val db = Database.connect("jdbc:sqlite:$filePath", "org.sqlite.JDBC")
        db.useNestedTransactions = true
        TransactionManager.manager.defaultIsolationLevel = Connection.TRANSACTION_SERIALIZABLE
        return db
    }

    fun run(runMode: RunMode): IO<Either<AppError, List<GitHubMetric>>> =
        EitherT.monad<AppError, ForIO>(IO.monad()).fx.monad {
            App.connectToDatabase()

            val people = ! EitherT(CsvUserImporter.importUsers)

            val result =
                ! if (runMode == RunMode.PARALLEL) {
                    println("::: Running in parallel :::")
                    EitherT(PeopleProcessor.processPeopleParallel(people))
                } else {
                    println("::: Running normal :::")
                    EitherT(PeopleProcessor.processPeople(people))
                }

            result
        }.value().fix()
}

/*
// Short example for EitherT
data class Failure(val reason: String)
fun x() : IO<Either<Failure,String>> = IO { "x".right() }
fun y(xResult: String) : IO<Either<Failure,Int>> { return IO { Failure(xResult).left() } }
fun z(yResult: Int) : IO<Either<Failure,String>> { return IO { "$yResult".right() } }
fun compute(): IO<Either<Failure, String>> = EitherT.monad<Failure, ForIO>(IO.monad()).fx.monad {
    val xResult = ! EitherT(x())
    val yResult = ! EitherT(y(xResult))
    ! EitherT(z(yResult))
}.value().fix()
 */
